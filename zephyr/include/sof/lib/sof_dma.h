/* SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2025, Intel Corporation.
 */

/*
 * Need to use sof_dma.h to avoid "syscalls/dma.h" name conflict
 * with Zephyr autogenerated headers for syscall support.
 */

#ifndef SOF_DMA_H
#define SOF_DMA_H

/**
 * \brief API to request a platform DMAC.
 *
 * Users can request DMAC based on dev type, copy direction, capabilities
 * and access privilege.
 * For exclusive access, ret DMAC with no channels draining.
 * For shared access, ret DMAC with the least number of channels draining.
 */
__syscall struct sof_dma *sof_dma_get(uint32_t dir, uint32_t caps, uint32_t dev, uint32_t flags);

struct sof_dma *z_impl_sof_dma_get(uint32_t dir, uint32_t cap, uint32_t dev, uint32_t flags);


/**
 * \brief API to release a platform DMAC.
 *
 * @param[in] dma DMAC to release.
 */
__syscall void sof_dma_put(struct sof_dma *dma);

void z_impl_sof_dma_put(struct sof_dma *dma);

__syscall int sof_dma_get_attribute(struct sof_dma *dma, uint32_t type, uint32_t *value);

__syscall int sof_dma_request_channel(struct sof_dma *dma, uint32_t stream_tag);

__syscall void sof_dma_release_channel(struct sof_dma *dma,
				       uint32_t channel);

__syscall int sof_dma_config(struct sof_dma *dma, uint32_t channel,
			     struct dma_config *config);

__syscall int sof_dma_start(struct sof_dma *dma, uint32_t channel);

__syscall int sof_dma_stop(struct sof_dma *dma, uint32_t channel);

__syscall int sof_dma_get_status(struct sof_dma *dma, uint32_t channel, struct dma_status *stat);

__syscall int sof_dma_reload(struct sof_dma *dma, uint32_t channel, size_t size);

__syscall int sof_dma_suspend(struct sof_dma *dma, uint32_t channel);

__syscall int sof_dma_resume(struct sof_dma *dma, uint32_t channel);

static inline int z_impl_sof_dma_get_attribute(struct sof_dma *dma, uint32_t type, uint32_t *value)
{
	return dma_get_attribute(dma->z_dev, type, value);
}

static inline int z_impl_sof_dma_request_channel(struct sof_dma *dma, uint32_t stream_tag)
{
	return dma_request_channel(dma->z_dev, &stream_tag);
}

static inline void z_impl_sof_dma_release_channel(struct sof_dma *dma,
						  uint32_t channel)
{
	dma_release_channel(dma->z_dev, channel);
}

static inline int z_impl_sof_dma_config(struct sof_dma *dma, uint32_t channel,
					struct dma_config *config)
{
	return dma_config(dma->z_dev, channel, config);
}


static inline int z_impl_sof_dma_start(struct sof_dma *dma, uint32_t channel)
{
	return dma_start(dma->z_dev, channel);
}

static inline int z_impl_sof_dma_stop(struct sof_dma *dma, uint32_t channel)
{
	return dma_stop(dma->z_dev, channel);
}

static inline int z_impl_sof_dma_get_status(struct sof_dma *dma, uint32_t channel,
					    struct dma_status *stat)
{
	return dma_get_status(dma->z_dev, channel, stat);
}

static inline int z_impl_sof_dma_reload(struct sof_dma *dma, uint32_t channel, size_t size)
{
	return dma_reload(dma->z_dev, channel, 0, 0, size);
}

static inline int z_impl_sof_dma_suspend(struct sof_dma *dma, uint32_t channel)
{
	return dma_suspend(dma->z_dev, channel);
}

static inline int z_impl_sof_dma_resume(struct sof_dma *dma, uint32_t channel)
{
	return dma_resume(dma->z_dev, channel);
}

#ifdef CONFIG_SOF_USERSPACE_INTERFACE_DMA

/* include definitions from generated file */
#include <zephyr/syscalls/sof_dma.h>

#else /* !CONFIG_SOF_USERSPACE_INTERFACE_DMA */

/*
 * SOF-specific mechanism to allow building SOF with user-space
 * support enabled in Zephyr, but not including all syscall
 * interfaces in the SOF binary. Thee downside is we cannot
 * use the zephyr/syscalls/sof_dma.h boilerplate that is autogenerated
 * but instead need a manual wrapper that is below here.
 *
 * This can be removed if DMA is used in all SOF user-space builds.
 */

static inline struct sof_dma *sof_dma_get(uint32_t dir, uint32_t caps, uint32_t dev, uint32_t flags)
{
	return z_impl_sof_dma_get(dir, caps, dev, flags);
}

static inline void sof_dma_put(struct sof_dma *dma)
{
	return z_impl_sof_dma_put(dma);
}

static inline int sof_dma_get_attribute(struct sof_dma *dma, uint32_t type, uint32_t *value)
{
	return z_impl_sof_dma_get_attribute(dma, type, value);
}

static inline int sof_dma_request_channel(struct sof_dma *dma, uint32_t stream_tag)
{
	return z_impl_sof_dma_request_channel(dma, stream_tag);
}

static inline void sof_dma_release_channel(struct sof_dma *dma,
					   uint32_t channel)
{
	return z_impl_sof_dma_release_channel(dma, channel);
}

static inline int sof_dma_config(struct sof_dma *dma, uint32_t channel,
				 struct dma_config *config)
{
	return z_impl_sof_dma_config(dma, channel, config);
}

static inline int sof_dma_start(struct sof_dma *dma, uint32_t channel)
{
	return z_impl_sof_dma_start(dma, channel);
}

static inline int sof_dma_stop(struct sof_dma *dma, uint32_t channel)
{
	return z_impl_sof_dma_stop(dma, channel);
}

static inline int sof_dma_get_status(struct sof_dma *dma, uint32_t channel, struct dma_status *stat)
{
	return z_impl_sof_dma_get_status(dma, channel, stat);
}

static inline int sof_dma_reload(struct sof_dma *dma, uint32_t channel, size_t size)
{
	return z_impl_sof_dma_reload(dma, channel, size);
}

static inline int sof_dma_suspend(struct sof_dma *dma, uint32_t channel)
{
	return z_impl_sof_dma_suspend(dma, channel);
}

static inline int sof_dma_resume(struct sof_dma *dma, uint32_t channel)
{
	return z_impl_sof_dma_resume(dma, channel);
}

#endif /* CONFIG_SOF_USERSPACE_INTERFACE_DMA */

#endif
